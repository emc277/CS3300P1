<!doctype html>
<html>
<head>
	<title>Global Emoji</title>
	<link href="https://fonts.googleapis.com/css?family=Alegreya|Alegreya+Sans" rel="stylesheet">
	<style>
		svg{
			padding-left: 50px;
			padding-top: 50px;
		}

		p{
			font-family: 'sans-serif';
		}

		.visualization{
			border-radius: 25px;
			background: #343F51; 
			display: block;
			margin: auto;
		}

		.header{
			border-radius: 25px;
			background: #364C64; 
			display: block;
			margin: auto;
		}

		.legend{
			border-radius: 25px;
			background: #980B0B; 
		}

		.title{
			text-align: center;
			font-size:300%;
			font-family:'sans-serif';
			color:orange;
		}

		.subtitle{
			text-align: center;
			font-size:200%;
			font-family:'sans-serif';
			color:orange;
		}

		.axisWhite line{
			  stroke: white;
		}

		.axisWhite path{
		  stroke: none;
		}

		.axisWhite text{
		  fill: white;
		} 


	</style>
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="http://d3js.org/topojson.v2.min.js"></script>
	<script src="./node_modules/d3-svg-legend/d3-legend.min.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
	<body style = 'background-color:#1D2129'>
			<!-- <div align = 'center' style = 'border-radius: 25px;
    					background: #343F51; height: 800px; width: 1300px'>
			<svg id = "cloud" width = "1000" height = "1000" style = 'display: inline-block;'/>
			<script>

				var parseLine = function(line){
					line.Negative = +line.Negative;
					line.Neutral = +line.Neutral;
					line.Occurrences = +line.Occurrences;
					line.Position = +line.Position;
					line.Positive = +line.Positive;
					var temp = line.Positive - line.Negative;
					var negscoreScale = d3.scaleLinear().domain([-666,0]).range([-1.0,0.0]);
					var posscoreScale = d3.scaleLinear().domain([0,6006]).range([0.0,1.0]);
					if (temp>0){
						line.Score=posscoreScale(temp);
					}
					if (temp<=0){
						line.Score=negscoreScale(temp);
					}
					if (line.Score==0){
						line.Score=.001;
					}
					//line.Neutral = line.Neutral/4164;
					var neutralScaler = d3.scaleLog().domain([83,4164]).range([0.0,1.0]);
					line.Neutral = neutralScaler(line.Neutral);

					//console.log(line.World);
					if(line.Language != undefined){
						if(hasNumber(line.Language)){
							console.log('has number');
							line.World = line.Language;
							line.Language = '';
						}
					}
					else{
						line.Language = '';
					}
					if(line.World != undefined){
						line.World = line.World.split(' ').forEach(function(w)
								{return +w;});
					}
					return line;
				}
				var raw_data_3 = d3.csv("Emoji.csv", parseLine, function(error, data){
					//console.log('here');
					//console.log(data);
					makeCloud(data);
				});

				var cld = d3.select('#cloud');
				function getFreqs(data){
					var toReturn = []
					var topList = getTop(data,500);
					var sizeExtent = d3.extent(topList, function(d){return d.Occurrences});
					var sizeScale = d3.scaleLinear().domain(sizeExtent).range([20,150]);
					topList.forEach(function(d){
						toReturn.push({'text': d.Emoji, 'size': sizeScale(d.Occurrences)});});
					return toReturn;
				}

				function makeCloud(data){
					var frequencyList = getFreqs(data);
					d3.cloud().size([900, 700])
			            .words(frequencyList)
			            //.rotate(0)
			            .padding(0)
			            .fontSize(function(d) { return d.size; })
			            //.spiral('rectangular')
			            .on("end", draw)
			            .start();
		        }

	         	function draw(words) {
	         		console.log(words);
	        		cld.append('svg')
		                .attr("width", 950)
		                .attr("height", 950)
		                .attr("class", "wordcloud")
		                .append("g")
		                // without the transform, words words would get cutoff to the left and top, they would
		                // appear outside of the SVG area
		                .attr("transform", "translate(350,400)")
		                .selectAll("text")
		                .data(words)
		                .enter().append("text")
		                .style("font-size", function(d) { return d.size + "px"; })
		                .style("fill", 'red')
		                .attr("transform", function(d) {
		                    return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
		                })
		                .text(function(d) { return d.text; });
    			}
			</script>
		</div> -->
		<div>
			<p class = 'title' style='font-family:sans-serif'>The Emoji Report</p>
			<p class = 'subtitle' style='font-family:sans-serif'>Modern communication across the globe.</p>
		</div>
		<div>
			<svg id = "chart" class = "visualization" width = "1200" height = "700"/>
			<script>
				var svg = d3.select("#chart");
				var usableData = [];
				var parseLine = function(line){
					line.Negative = +line.Negative;
					line.Neutral = +line.Neutral;
					line.Occurrences = +line.Occurrences;
					line.Position = +line.Position;
					line.Positive = +line.Positive;
					var temp = line.Positive - line.Negative;
					var negscoreScale = d3.scaleLinear().domain([-666,0]).range([-1.0,0.0]);
					var posscoreScale = d3.scaleLinear().domain([0,6006]).range([0.0,1.0]);
					if (temp>0){
						line.Score=posscoreScale(temp);
					}
					if (temp<=0){
						line.Score=negscoreScale(temp);
					}
					if (line.Score==0){
						line.Score=.001;
					}
					//line.Neutral = line.Neutral/4164;
					var neutralScaler = d3.scaleLog().domain([83,4164]).range([0.0,1.0]);
					line.Neutral = neutralScaler(line.Neutral);

					//console.log(line.World);
					if(line.Language != undefined){
						if(hasNumber(line.Language)){
							console.log('has number');
							line.World = line.Language;
							line.Language = '';
						}
					}
					else{
						line.Language = '';
					}
					if(line.World != undefined){
						line.World = line.World.split(' ').forEach(function(w)
								{return +w;});
					}
					return line;
				}

				function hasNumber(str){
					return /\d/.test(str);
				}

				/*function filterDingbats(data){
					//console.log(data.length);
					data.filter(
						function(d){
							console.log(d);
							return !(d.info['Unicode block'].includes('Dingbats') ||
								d.info['Unicode block'].includes('Geometric'));
						}
					);
				}*/
					

				var raw_data = d3.csv("Emoji.csv", parseLine, function(error, data){
					console.log('here');
					console.log(data);
					showData(data);
				});
				console.log(raw_data);
				function getTop(data, n){
					data.sort(function(a,b){return b.Occurrences - a.Occurrences;});
					return data.slice(0,n);
				}

				function showData(data){
					//top 50 displayed
					//gradient
					var gradient = svg.append("defs")
						.append("linearGradient")
					    .attr("id", "gradient")
					    .attr("x1", "0%")
					    .attr("y1", "0%")
					    .attr("x2", "100%")
					    .attr("y2", "0%")
					    .attr("spreadMethod", "pad");
					gradient.append("stop")
					    .attr("offset", "0%")
					    .attr("stop-color", "#c00")
					    .attr("stop-opacity", 1);
					gradient.append("stop")
						.attr("offset", "50%")
						.attr("stop-color", "#fff")
						.attr("stop-opacity", 1);
					gradient.append("stop")
					    .attr("offset", "100%")
					    .attr("stop-color", "blue")
					    .attr("stop-opacity", 1);

					//need a white rectangle in the backgroud so that a
					//more opaque gradient appears lighter
					svg.append("rect")
						.attr("width", 1000)
					    .attr("height", 550)
					    .attr("x", 50)
					    .attr("y", 50)
					    .style('fill', 'white');

					svg.append("rect")
					    .attr("width", 1000)
					    .attr("height", 550)
					    .attr("x", 50)
					    .attr("y", 50)
					    .style("fill-opacity", .8)
					    .style("fill", "url(#gradient)");

					var top75 = getTop(data, 75);
					/*var neutralExtent = d3.extent(top_50, function(d){return d.Neutral;});
					var neutralScale = d3.scaleLinear().domain(neutralExtent).range([50,650]);
					var scoreExtent = d3.extent(top_50, function(d){return d.Score;});
					var scoreScale = d3.scaleLinear().domain(scoreExtent).range([40,960]);
					var occurExtent = d3.extent(top_50, function(d){return d.Occurrences;});
					console.log(occurExtent);
					var occurScale = d3.scaleLinear().domain(occurExtent).range([10,50]);
					top_50.forEach(function(d){
						/*var xPos = scoreScale(d.Score);
						var yPos = neutralScale(d.Neutral);
						d['x'] = xPos;
						d['y'] = ypos;
						svg.append('text')
							.text(d.Emoji)
							.attr("height", occurScale(d.Occurrences))
							.attr("width", occurScale(d.Occurrences))
							.style("font-size", occurScale(d.Occurrences))
							.attr("x", scoreScale(d.Score))
							.attr("y", neutralScale(d.Neutral));
					});
					var xAxis = d3.axisBottom(scoreScale);
					svg.append('g')
						.call(xAxis)
						.attr('transform', 'translate(0,680)');
					var yAxis = d3.axisLeft(neutralScale);
					svg.append('g')
						.call(yAxis)
						.attr('transform', 'translate(20,0)');
				}*/

					var neutralExtent = d3.extent(top75, function(d){return (d.Neutral);});
					var neutralScale = d3.scaleLinear().domain(neutralExtent).range([600,100]);
					var scoreExtent = d3.extent(top75, function(d){return (d.Score);});
					scoreExtent = [scoreExtent[0]-.05,scoreExtent[1]+.05];
					var scoreScale = d3.scaleLinear().domain(scoreExtent).range([50,1050]);
					var occurExtent = d3.extent(top75, function(d){return d.Occurrences;});
					console.log("OCCUR EXTENT");
					console.log(occurExtent);
					var occurScale = d3.scaleLog().domain(occurExtent).range([600,100]);

					var xAxis = d3.axisBottom(scoreScale);
					var yAxis = d3.axisLeft(occurScale)
						.ticks(5, ",.1s");
					svg.append('g')
						.call(xAxis)
						.attr('transform', 'translate(0,600)')
						.attr('class', 'axisWhite');
						//.tickValues([]);
					svg.append('g')
						.call(yAxis)
						//.ticks(5, ",.1s")
						.attr('transform', 'translate(50,0)')
						.attr('class', 'axisWhite');
						//.ticks(7, ",.1s");
						//.attr('transform', 'rotate(90)');
					svg.append("text")
						.attr("transform", "translate(550,640)")
						.style("font-family", "Verdana")
						.style("font-size", "14")
						.attr("fill", "white")
						.style("text-anchor", "middle")
						.text("Sentiment Score");
					svg.append("text")
						.attr("transform", "translate(100,640)")
						.attr("fill", "white")
						.style("font-family", "Verdana")
						.style("font-size", "14")
						.style("text-anchor", "middle")
						.text("Negative");
					svg.append("text")
						.attr("transform", "translate(1000,640)")
						.attr("fill", "white")
						.style("font-family", "Verdana")
						.style("font-size", "14")
						.style("text-anchor", "middle")
						.text("Positive");
					svg.append("text")
						.attr("transform", "rotate(90); translate(1000, 300)")
						.style("font-family", "Verdana")
						.style("font-size", "14")
						.style("text-anchor", "middle")
						.style("alignment-baseline", "middle")
						.text("Frequency of use");
					svg.append("text")
						.attr("transform", "translate(590,20)")
						.attr("fill", "orange")
						.style("font-family", "Verdana")
						.style("font-size", "22")
						.style("text-anchor", "middle")
						.text("Popularity of Emojis by Sentiment");

					top75.forEach(function(d){
						/*var xPos = scoreScale(d.Score);
						var yPos = neutralScale(d.Neutral);
						d['x'] = xPos;
						d['y'] = ypos;*/
						//console.log(scoreScale(d.Score));
						//if (!(d.Score<0.51 && d.Score>0.49)){
						//if (d.Unicode_name.includes("Black")){
						//console.log("unicode name???");
						//console.log(d.Unicodename);
						svg.append('text')
							.text(d.Emoji)
							.attr("height", 20)
							.attr("width", 20)
							.style("font-size", 20)
							.style("text-anchor", "middle")
							.style("alignment-baseline", "middle")
							.attr("x", scoreScale(d.Score))
							.attr("y", occurScale(d.Occurrences));
						//}
					});
				}

				/*function drawEllipse(category,color){
					var x_coords = category.map(function(d){return d.x;});
					var y_coords = category.map(function(d){return d.y;});
					var x_max = Math.max.apply(null,x_coords);
					var x_min = Math.min.apply(null,x_coords);
					var y_max = Math.max.apply(null,y_coords);
					var y_min = Math.min.apply(null,y_coords);
					// var x_radius = Math.max.apply(null,x_coords) - Math.min.apply(null,x_coords);
					// var y_radius = Math.max.apply(null,y_coords) - Math.min.apply(null,y_coords);
					//var x_center = 

					svg.append('ellipse')
						.attr('cx', (x_min + (x_max - x_min)/2))
						.attr('cy', (y_min + (y_max - y_min)/2))
						.attr('rx', (x_max - x_min)/2)
						.attr('ry', (y_max - y_min)/2)
						.attr('transform', 'rotate()')
				}*/

				/*function createPaths(category, color){
					var points = pathData(category);
					var lineGenerator = d3.svg.line()
												.x(function(d){return d.x;})
												.y(function(d){return d.y;});

				}

				//might be redundant
				function pathData(category){
					var toReturn = [];
					category.forEach(function(d){
						var coords = {'x': d.x, 'y': d.y};
						toReturn.push(coords);});
					return toReturn;
				}*/
				console.log('terminated');

			</script>	
		</div>
		<br><br>
			<svg id = "piethingy" class = "visualization" width = "1200" height = "1000"/>
			<!-- <svg id = 'legend' width = '200' height = '400'/> -->
			<script>
				var backdrop = d3.select('#piethingy');
				backdrop.append('text')
					.attr('x', '600')
					.attr('y', '30')
					.attr('text-anchor', 'middle')
					.attr('font-size', 30)
					.attr('fill', 'orange')
					.attr('font-family', 'Verdana')
					.text("Popular Emoji Categories by Country");
				//var legend = d3.select('#legend');
				var circleCenter = [500, 350];
				var circleRadius = 325;

				var raw_data_2 = d3.csv("Emoji.csv", parseLine, function(error, data){
					console.log('here');
					console.log(data);
					circleData(data);
				});

				//Inspired by: http://bl.ocks.org/bycoffe/3404776
				function generateTextBlocks(numCircles, radius){
					var toReturn = [];
					var width = (radius*2);
					var angle, x, y = 0;
					for (var i = 0; i < numCircles; i++) {
						angle = (i/ (numCircles/2))*Math.PI;
						x = ((radius-20) * Math.cos(angle)) + (width/2);
          				y = ((radius-20) * Math.sin(angle)) + (width/2);
          				toReturn.push({'id': i, 'x': (x+185), 'y': (y+25)})
					}
					return toReturn;
					console.log(toReturn.length);
				}

				function getMatchingCategory(data, curr){
					var toReturn = data.filter(function(d){
							if(d.Emoji == curr.Emoji)
								return false;
							if(d.Category != undefined)
									return d.Category == curr.Category;
							else
								return false;
						})
						.map(function(d){return d.Emoji;})
						.join(' ');
					return toReturn;
				}

				function circleData(data){
					//var top30 = getTop(data, 30);
					//var emojis = top30.map(function(d){return d.Emoji;}).join(' ');
					//console.log(data);
					var filtered = data.filter(function(d){
						return d.Language != '';
					});

					filtered.sort(function(a,b){return a.Language.localeCompare(b.Language);});
					var languages = filtered.map(function(d){return d.Language;});
					console.log('filtered');
					console.log(filtered.length);
					//data.forEach(function(d){console.log(d.Language);});

					var emojis = filtered.map(function(d){return d.Emoji;}).join('        ');
					console.log(emojis);
					console.log(filtered);
					var colorScale = d3.scaleOrdinal().domain(languages)
													.range(d3.schemeCategory10);
					//var colors = d3.schemeCategory20().domain([])

					//create circular path
					/*backdrop.append('path')
						.attr('id', 'curve')
						.attr('fill', 'none')
						.attr('d', "M" + circleCenter[0] + "," + circleCenter[1] + " " +
						           "m" + -circleRadius + ", 0 " +
						           "a" + circleRadius + "," + circleRadius + " 0 1,0 " + 
						           			circleRadius*2  + ",0 " +
						           "a" + circleRadius + "," + circleRadius + " 0 1,0 " + 
						           			-circleRadius*2 + ",0Z");
						           				
					//add the text around the circle
					backdrop.append("text")
					    .attr("id", "curve-text")
					  	.append("textPath")
					  	//.attr("startOffset","40%")
						//.style("text-anchor","middle")
					    .attr("xlink:href", "#curve")
					    .style('font-size', 45)
					    .text(emojis);				
					backdrop.append("use")
					    .attr("id", "curve-line")
					    .attr("xlink:href", "#curve");*/

					//small circle	
					/*for (var k = 0; k < 26; k++) {
						backdrop.append('path')
							.attr('class', 'small-circle')
							.attr('fill', 'red')
							.attr('d', "M" + (495) + "," + 
										(653) + " " +
							           "m" + -35 + ", 0 " +
							           "a" + 35 + "," + 35 + " 0 1,0 " + 
							           			35*2  + ",0 " +
							           "a" + 35 + "," + 35 + " 0 1,0 " + 
							           			-35*2 + ",0Z")
							.attr('transform', 'translate(' + 498 + ',' + );
					}*/

					var smallCircleRadius = 60;
					var smallerCircleRadius = 45;
					console.log(filtered);
					var textElems = [];
					var coords = generateTextBlocks(filtered.length, circleRadius);

					var viz = backdrop.append('g');
					for (var j = 0; j < coords.length; j++){
						viz.append('line')
								.attr('x1', (circleCenter[0]))
								.attr('y1', (circleCenter[1]))
								.attr('x2', coords[j].x)
								.attr('y2', coords[j].y)
								.style('stroke', colorScale(filtered[j].Language))
								.style('stroke-width', 5);
						viz.append('path')
								//.attr('stroke', colorScale(filtered[j].Language))
								.attr('fill', 'none')
								//.attr('stroke-width', 3)
								.attr('id', ('circle'+j))
								.attr('d', "M" + coords[j].x + "," + 
											coords[j].y + " " +
								           "m" + (-smallCircleRadius) + ", 0 " +
								           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " + 
								           			smallCircleRadius*2  + ",0 " +
								           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " + 
								           			-smallCircleRadius*2 + ",0Z")
								.attr('transform', 'rotate('+ (25.7*j) + ',' +	coords[j].x + ',' + coords[j].y +')');
						viz.append('path')
							.attr('fill', 'none')
							.attr('id', ('square'+j))
							.attr('d', "M" + coords[j].x +","+coords[j].y + "," +
								"M" + (coords[j].x-90)+","+ (coords[j].y+90) + " " +
								"L" + (coords[j].x+90) + "," + (coords[j].y+90) +" " +
								"L" + (coords[j].x+90) + "," + (coords[j].y-90) + " " +
								"L" + (coords[j].x-90) + "," + (coords[j].y-90) + " Z")
							.attr('transform', 'rotate('+ (25.7*j) + ',' +	coords[j].x + ',' + coords[j].y +')');

						/*viz.append('path')
								.attr('stroke', colorScale(filtered[j].Language))
								.attr('fill', 'white')
								.attr('stroke-width', 5)
								//.attr('id', ('circle'+j))
								.attr('d', "M" + coordsBig[j].x + "," + 
											coordsBig[j].y + " " +
								           "m" + (-smallerCircleRadius-10) + ", 0 " +
								           "a" + smallerCircleRadius + "," + smallerCircleRadius + " 0 1,0 " + 
								           			smallerCircleRadius*2  + ",0 " +
								           "a" + smallerCircleRadius + "," + smallerCircleRadius + " 0 1,0 " + 
								           			-smallerCircleRadius*2 + ",0Z")
								.attr('transform', 'rotate('+ (25.7*j) + ',' +	coordsBig[j].x + ',' + coordsBig[j].y +')');*/
						viz.append('circle')
								.attr('stroke', colorScale(filtered[j].Language))
								.attr('fill', 'white')
								.attr('stroke-width', 5)
								//.attr('id', ('circle'+j))
								.attr('cx', coords[j].x)
								.attr('cy', coords[j].y)
								.attr('r', smallerCircleRadius);

						viz.append('text')
										.attr('id', coords[j].id)
										.style('text-anchor', 'middle')
										.style('dominant-baseline', 'central')
										.attr('x', coords[j].x)
										.attr('y', coords[j].y)
										//.attr('width', 90)
										//.attr('height',90)
										.style('font-size', 50)
										.text(filtered[j].Emoji);
										//.attr('transform', 'rotate('+ (25.7*j) + ',' +	coordsBig[j].x + ',' + coordsBig[j].y +')');

						//Big emoji in center
						viz.append('text')
							.attr('x', circleCenter[0])
							.attr('y', circleCenter[1])
							.attr('text-anchor', 'middle')
							.style('font-size', 100)
							.style('alignment-baseline', 'middle')
							.text(data[0].Emoji);

						var matchingEmojis = getMatchingCategory(data, filtered[j]);

						viz.append("text")
							    .attr("id", "small-curve-text")
							  	.append("textPath")
							  	.attr("startOffset","50%")
								.style("text-anchor","middle")
								.style('alignment-baseline', 'hanging')
							    .attr("xlink:href", ("#circle"+(j)))
							    .style('font-size', 35)
							    //.attr('x', 10)
							    //.attr('text-anchor', 'begin')
							    .text(matchingEmojis);				
						viz.append("use")
							    .attr("id", "small-curve-line")
							    .attr("xlink:href", "#circle"+(j));

						viz.append("text")
							    .attr("id", "label-text")
							  	.append("textPath")
							  	.attr("startOffset","37.5%")
								.style("text-anchor","middle")
								.style('alignment-baseline', 'hanging')
							    .attr("xlink:href", ("#square"+(j)))
							    .style('font-size', 20)
							    .style('font-family', 'sans-serif')
							    .style('fill', 'white')
							    .text(filtered[j].Category);	
						viz.append("use")
							    .attr("id", "label-text")
							    .attr("xlink:href", "#square"+(j));
					}

					viz.attr('transform', 'translate(-80,150)');

					var legend = backdrop.append('svg')
										.attr('class', 'legend');

					legend.append('rect')
						.attr('width', '175')
						.attr('height', '270')
						.attr('rx', '15')
						.attr('ry', '15')
						.attr('fill', '#1D2129')
						.attr('fill-opacity', '.4')
						.attr('transform', 'translate(950,355)');

					legend.append("g")
						  .attr("class", "legendSymbol")
						  .attr('fill', 'white')
						  .attr('font-family', 'sans-serif')
						  .attr('width', '170')
						  .attr('height', '270')
						  .attr("transform", "translate(975, 420)");

					var legendPath = d3.legendColor()
					  .scale(colorScale)
					  .orient("vertical")
					  .title("Countries");

					legend.select(".legendSymbol")
					  .call(legendPath);

					/*for (var i = 0; i < coords.length; i++) {
						console.log(filtered[i]);
						console.log(coords[i]);
						var elem = backdrop.append('text')
												.attr('id', coords[i].id)
												.attr('x', coords[i].x)
												.attr('y', coords[i].y)
												.style('text-anchor', 'middle')
												.style('alignment-baseline', 'middle')
												//.attr('width', 40)
												//.attr('height',40)
												.style('font-size', 60)
												.text(filtered[i].Emoji);
						textElems.push(elem);
					}*/


					/*var angle = 0;
					//Split into two loops because the emoji at angle 0 is
					//at filtered[6]
					var smallCircleRadius = 50;
					for (var i = 3; i < filtered.length; i++) {
						angle = -(24*(i-3))
						console.log((i-3));
						backdrop.append('line')
								.attr('x1', circleCenter[0])
								.attr('y1', circleCenter[1])
								.attr('x2', circleCenter[0])
								.attr('y2', circleCenter[1]+ (circleRadius-70))
								.style('stroke', colorScale(filtered[i].Language))
								.style('stroke-width', 2)
								.attr('transform', 'rotate(' + angle + ',' 
															+ circleCenter[0] + ','
															+ circleCenter[1]+')');
						var smallCircle = backdrop.append('path')
									.attr('id', (i-6))
									.attr('fill', 'none')
									.attr('d', "M" + circleCenter[0] + "," + 
												(circleCenter[1] + circleRadius+10) + " " +
									           "m" + -smallCircleRadius + ", 0 " +
									           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " + 
									           			smallCircleRadius*2  + ",0 " +
									           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " + 
									           			-smallCircleRadius*2 + ",0Z")
									.attr('transform', 'rotate(' + angle + ',' 
																+ circleCenter[0] + ','
																+ circleCenter[1]+')');
						var matchingEmojis = getMatchingCategory(data, filtered[i]);

						backdrop.append("text")
							    .attr("id", "small-curve-text")
							  	.append("textPath")
							  	.attr("startOffset","25%")
								.style("text-anchor","middle")
							    .attr("xlink:href", ("#"+(i-6)))
							    .style('font-size', 17)
							    //.attr('x', 10)
							    //.attr('text-anchor', 'begin')
							    .text(matchingEmojis);				
						backdrop.append("use")
							    .attr("id", "small-curve-line")
							    .attr("xlink:href", "#"+(i-6));
					}

					for (var j = 0; j < 3; j++) {
						var angleCount = j+ 12;
						angle = -(24*(angleCount));
						console.log(angle);
						console.log('index: ' + (j+12));
						console.log(j);
						console.log(filtered[j]);
						var lineAdded = backdrop.append('line')
									.attr('x1', circleCenter[0])
									.attr('y1', circleCenter[1])
									.attr('x2', circleCenter[0])
									.attr('y2', circleCenter[1]+ (circleRadius - 70))
									.style('stroke', colorScale(filtered[j].Language))
									.style('stroke-width', 2)
									.attr('transform', 'rotate(' + angle + ',' 
																+ circleCenter[0] + ','
																+ circleCenter[1]+')');
						backdrop.append('path')
									.attr('id', angleCount)
									.attr('fill', 'none')
									.attr('d', "M" + circleCenter[0] + "," + 
												(circleCenter[1] + circleRadius+10) + " " +
									           "m" + -smallCircleRadius + ", 0 " +
									           "a" + smallCircleRadius/2 + "," + smallCircleRadius/2 + " 0 0,0 " + 
									           			smallCircleRadius*2  + ",0 " +
									           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " +
									           			-smallCircleRadius*2 + ",0Z")
									.attr('transform', 'rotate(' + angle + ',' 
																+ circleCenter[0] + ','
																+ circleCenter[1]+')');
						var matchingEmojis = getMatchingCategory(data, filtered[j]);

						backdrop.append("text")
							    .attr("id", "small-curve-text")
							  	.append("textPath")
							  	.attr("startOffset","50%")
								.style("text-anchor","middle")
							    .attr("xlink:href", ("#"+(angleCount+1)))
							    .style('font-size', 17)
							    //.attr('x', 30)
							    //.attr('text-anchor', 'begin')
							    .text(matchingEmojis);				
						backdrop.append("use")
							    .attr("id", "small-curve-line")
							    .attr("xlink:href", "#"+(angleCount+1));
						i += 1;
						console.log('after increment: ' + i);
					}
					//var circleData = generateSmallCircles(26, (circleRadius));
					//console.log(circleData.length);
					//circleData.forEach(function(c){
					//backdrop.selectAll('line').append('circle').attr('fill', "red");	
						

					//});
					/*d3.selectAll('.small-circle')
						.enter()*/

				}
			</script>
		<br><br>
		<div>
			<svg id = 'map' class = "visualization" width = '1200' height = '700'>
				<svg class = 'header' width = '1100' height = '100'>
			</svg>
			<script>

				var map = d3.select("#map");
				map.append('text')
					.attr('x', '600')
					.attr('y', '30')
					.attr('text-anchor', 'middle')
					.attr('font-size', 30)
					.attr('fill', 'orange')
					.attr('font-family', 'Verdana')
					.text("Most Popular Emojis by State");
				var path = d3.geoPath();

				d3.queue()
					.defer(d3.tsv, "us-state-names.tsv")
					.defer(d3.csv, "State_Emoji.csv")
					.await(drawMap)

				/*var stateNames = d3.tsv("us-state-names.tsv");
				console.log(stateNames);
				var raw_data_5 = d3.csv("State_Emoji.csv", function(error, data){
					console.log('here');
					console.log(data);
					draw(data);
				});*/

				function getStateById(i, stateNames){
					for (var l = 0; l < stateNames.length; l++) {
						if((+stateNames[l].id) == i){
							console.log(stateNames[l].name);
							return stateNames[l].name
						}
					}
					return '';
				}

				function getEmojiByState(state, stateEmojis){
					for (var m = 0; m < stateEmojis.length; m++) {
						if(stateEmojis[m].State == state){
							console.log(stateEmojis[m].Emoji)
							return stateEmojis[m].Emoji;
						}
					}
					return '';
				}

				function drawMap(error, stateNames, stateEmojis){
					console.log(stateNames);
					console.log(stateEmojis);
					d3.json("https://d3js.org/us-10m.v1.json", function(error, us) {
					  if (error) throw error;
					 var stateData = topojson.feature(us, us.objects.states).features;
					 var stateBorders = topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; });
					  

					   appendEmojis(stateData, stateEmojis, stateNames, stateBorders);

					});

					var elements = map.append("g")

					function appendEmojis(stateData, stateEmojis, stateNames, stateBorders){
						elements.append("g")
					      .attr("class", "states")
					    .selectAll("path")
					    .data(stateData)
					    .enter().append("path")
					      .attr("d", path)
					      .style('fill', '#1D2129')
					      //.attr('fill-opacity', .3);

					  elements.append("path")
					      .attr("class", "state-borders")
					      .attr("d", path(stateBorders))
					      .attr('stroke-width', 2)
					      //.attr('stroke-opcaity', .1)
					      .attr('stroke', '#343F51')
					      .attr('fill', '#1D2129')
					      //.attr('fill-opacity', .3)
					      .style('stroke-linejoin', 'round')
					      .style('stroke-linecap', 'round');

						elements
							.selectAll('text')
							.data(stateData)
							.enter()
							.append('text')
							.text(function(d){
								console.log(d);
								var nm = getStateById((+d.id), stateNames);
								//console.log(nm);
								return getEmojiByState(nm, stateEmojis);})
							.attr('x', function(d){return path.centroid(d)[0];})
							.attr('y', function(d){return path.centroid(d)[1];})
							.attr('font-size', 30)
							.attr('stroke', "red")
							.attr('text-anchor', 'middle');
					}

					elements.attr('transform', 'translate(120,20)');

					
				}
			</script>
		</div>		
	</body>
</head>
</html>
<!doctype html>
<html>
<head>
	<title>HW3</title>
	<link href="https://fonts.googleapis.com/css?family=Alegreya|Alegreya+Sans" rel="stylesheet">
	<style>
	svg{
		padding-left: 50px;
		padding-top: 50px;
	}
	</style>
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="http://d3js.org/topojson.v2.min.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
	<body style = 'background-color:#33475b'>
			<svg id = "chart" width = "1100" height = "700">
			<script>
				var svg = d3.select("#chart");
				var usableData = [];
				function hasNumber(str){
					return /\d/.test(str);
				}
				var parseLine = function(line){
					line.Negative = +line.Negative;
					line.Neutral = +line.Neutral;
					line.Occurrences = +line.Occurrences;
					line.Position = +line.Position;
					line.Positive = +line.Positive;
					var temp = line.Positive - line.Negative;
					var negscoreScale = d3.scaleLinear().domain([-666,0]).range([-1.0,0.0]);
					var posscoreScale = d3.scaleLinear().domain([0,6006]).range([0.0,1.0]);
					if (temp>0){
						line.Score=posscoreScale(temp);
					}
					if (temp<=0){
						line.Score=negscoreScale(temp);
					}
					if (line.Score==0){
						line.Score=.001;
					}
					//line.Neutral = line.Neutral/4164;
					var neutralScaler = d3.scaleLog().domain([83,4164]).range([0.0,1.0]);
					line.Neutral = neutralScaler(line.Neutral);

					//console.log(line.World);
					if(line.Language != undefined){
						if(hasNumber(line.Language)){
							console.log('has number');
							line.World = line.Language;
							line.Language = '';
						}
					}
					else{
						line.Language = '';
					}
					if(line.World != undefined){
						line.World = line.World.split(' ').forEach(function(w)
								{return +w;});
					}
					return line;
				}
				var raw_data = d3.csv("Emoji.csv", parseLine, function(error, data){
					console.log('here');
					console.log(data);
					showData(data);
				});
				console.log(raw_data);
				function getTop(data, n){
					data.sort(function(a,b){return b.Occurrences - a.Occurrences;});
					return data.slice(0,n);
				}

				function showData(data){
					//top 50 displayed
					//gradient
					var gradient = svg.append("defs")
						.append("linearGradient")
					    .attr("id", "gradient")
					    .attr("x1", "0%")
					    .attr("y1", "0%")
					    .attr("x2", "100%")
					    .attr("y2", "0%")
					    .attr("spreadMethod", "pad");
					gradient.append("stop")
					    .attr("offset", "0%")
					    .attr("stop-color", "#c00")
					    .attr("stop-opacity", 1);
					gradient.append("stop")
						.attr("offset", "50%")
						.attr("stop-color", "#fff")
						.attr("stop-opacity", 1);
					gradient.append("stop")
					    .attr("offset", "100%")
					    .attr("stop-color", "blue")
					    .attr("stop-opacity", 1);
					svg.append("rect")
					    .attr("width", 1000)
					    .attr("height", 550)
					    .attr("x", 50)
					    .attr("y", 50)
					    .style("fill-opacity", .6)
					    .style("fill", "url(#gradient)");

					var top75 = getTop(data, 75);
					/*var neutralExtent = d3.extent(top_50, function(d){return d.Neutral;});
					var neutralScale = d3.scaleLinear().domain(neutralExtent).range([50,650]);
					var scoreExtent = d3.extent(top_50, function(d){return d.Score;});
					var scoreScale = d3.scaleLinear().domain(scoreExtent).range([40,960]);
					var occurExtent = d3.extent(top_50, function(d){return d.Occurrences;});
					console.log(occurExtent);
					var occurScale = d3.scaleLinear().domain(occurExtent).range([10,50]);
					top_50.forEach(function(d){
						/*var xPos = scoreScale(d.Score);
						var yPos = neutralScale(d.Neutral);
						d['x'] = xPos;
						d['y'] = ypos;
						svg.append('text')
							.text(d.Emoji)
							.attr("height", occurScale(d.Occurrences))
							.attr("width", occurScale(d.Occurrences))
							.style("font-size", occurScale(d.Occurrences))
							.attr("x", scoreScale(d.Score))
							.attr("y", neutralScale(d.Neutral));
					});
					var xAxis = d3.axisBottom(scoreScale);
					svg.append('g')
						.call(xAxis)
						.attr('transform', 'translate(0,680)');
					var yAxis = d3.axisLeft(neutralScale);
					svg.append('g')
						.call(yAxis)
						.attr('transform', 'translate(20,0)');
				}*/

					var neutralExtent = d3.extent(top75, function(d){return (d.Neutral);});
					var neutralScale = d3.scaleLinear().domain(neutralExtent).range([600,100]);
					var scoreExtent = d3.extent(top75, function(d){return (d.Score);});
					scoreExtent = [scoreExtent[0]-.05,scoreExtent[1]+.05];
					var scoreScale = d3.scaleLinear().domain(scoreExtent).range([50,1050]);
					var occurExtent = d3.extent(top75, function(d){return d.Occurrences;});
					console.log("OCCUR EXTENT");
					console.log(occurExtent);
					var occurScale = d3.scaleLog().domain(occurExtent).range([600,100]);

					var xAxis = d3.axisBottom(scoreScale);
					var yAxis = d3.axisLeft(occurScale)
						.ticks(5, ",.1s");
					svg.append('g')
						.call(xAxis)
						.attr('transform', 'translate(0,600)');
						//.tickValues([]);
					svg.append('g')
						.call(yAxis)
						//.ticks(5, ",.1s")
						.attr('transform', 'translate(550,0)');
						//.ticks(7, ",.1s");
						//.attr('transform', 'rotate(90)');
					svg.append("text")
						.attr("transform", "translate(550,640)")
						.style("font-family", "Verdana")
						.style("font-size", "14")
						.style("text-anchor", "middle")
						.text("Sentiment Score");
					svg.append("text")
						.attr("transform", "translate(100,640)")
						.style("font-family", "Verdana")
						.style("font-size", "14")
						.style("text-anchor", "middle")
						.text("(Negative)");
					svg.append("text")
						.attr("transform", "translate(1000,640)")
						.style("font-family", "Verdana")
						.style("font-size", "14")
						.style("text-anchor", "middle")
						.text("(Positive)");
					svg.append("text")
						.attr("transform", "translate(550,70)")
						.style("font-family", "Verdana")
						.style("font-size", "14")
						.style("text-anchor", "middle")
						.style("alignment-baseline", "middle")
						.text("Frequency of use");
					svg.append("text")
						.attr("transform", "translate(525,20)")
						.style("font-family", "Verdana")
						.style("font-size", "22")
						.style("text-anchor", "middle")
						.text("Emoji Sentiment vs. Frequency of use");

					top75.forEach(function(d){
						/*var xPos = scoreScale(d.Score);
						var yPos = neutralScale(d.Neutral);
						d['x'] = xPos;
						d['y'] = ypos;*/
						//console.log(scoreScale(d.Score));
						//if (!(d.Score<0.51 && d.Score>0.49)){
						//if (d.Unicode_name.includes("Black")){
						//console.log("unicode name???");
						//console.log(d.Unicodename);
						svg.append('text')
							.text(d.Emoji)
							.attr("height", 20)
							.attr("width", 20)
							.style("font-size", 20)
							.style("text-anchor", "middle")
							.style("alignment-baseline", "middle")
							.attr("x", scoreScale(d.Score))
							.attr("y", occurScale(d.Occurrences));
						//}
					});
				}

				/*function drawEllipse(category,color){
					var x_coords = category.map(function(d){return d.x;});
					var y_coords = category.map(function(d){return d.y;});
					var x_max = Math.max.apply(null,x_coords);
					var x_min = Math.min.apply(null,x_coords);
					var y_max = Math.max.apply(null,y_coords);
					var y_min = Math.min.apply(null,y_coords);
					// var x_radius = Math.max.apply(null,x_coords) - Math.min.apply(null,x_coords);
					// var y_radius = Math.max.apply(null,y_coords) - Math.min.apply(null,y_coords);
					//var x_center = 

					svg.append('ellipse')
						.attr('cx', (x_min + (x_max - x_min)/2))
						.attr('cy', (y_min + (y_max - y_min)/2))
						.attr('rx', (x_max - x_min)/2)
						.attr('ry', (y_max - y_min)/2)
						.attr('transform', 'rotate()')
				}*/

				/*function createPaths(category, color){
					var points = pathData(category);
					var lineGenerator = d3.svg.line()
												.x(function(d){return d.x;})
												.y(function(d){return d.y;});

				}

				//might be redundant
				function pathData(category){
					var toReturn = [];
					category.forEach(function(d){
						var coords = {'x': d.x, 'y': d.y};
						toReturn.push(coords);});
					return toReturn;
				}*/
				console.log('terminated');

			</script>
		</p>
		<p>
			<svg id = "piethingy" width = "1000" height = "1000"/><br>
			<svg id = 'legend' width = '200' height = '400'/>
			<script>
				var backdrop = d3.select('#piethingy');
				var legend = d3.select('#legend');
				var circleCenter = [500, 350];
				var circleRadius = 325;

				var raw_data_2 = d3.csv("Emoji.csv", parseLine, function(error, data){
					console.log('here');
					console.log(data);
					circleData(data);
				});

				//Inspired by: http://bl.ocks.org/bycoffe/3404776
				function generateTextBlocks(numCircles, radius){
					var toReturn = [];
					var width = (radius*2);
					var angle, x, y = 0;
					for (var i = 0; i < numCircles; i++) {
						angle = (i/ (numCircles/2))*Math.PI;
						x = (radius * Math.cos(angle)) + (width/2);
          				y = (radius * Math.sin(angle)) + (width/2);
          				toReturn.push({'id': i, 'x': (x+185), 'y': (y+25)})
					}
					return toReturn;
					console.log(toReturn.length);
				}

				function getMatchingCategory(data, curr){
					var toReturn = data.filter(function(d){
							if(d.Emoji == curr.Emoji)
								return false;
							if(d.Category != undefined)
									return d.Category == curr.Category;
							else
								return false;
						})
						.map(function(d){return d.Emoji;})
						.join(' ');
					return toReturn;
				}

				function circleData(data){
					//var top30 = getTop(data, 30);
					//var emojis = top30.map(function(d){return d.Emoji;}).join(' ');
					//console.log(data);
					var filtered = data.filter(function(d){
						return d.Language != '';
					});

					filtered.sort(function(a,b){return a.Language.localeCompare(b.Language);});
					var languages = filtered.map(function(d){return d.Language;});
					console.log('filtered');
					console.log(filtered.length);
					//data.forEach(function(d){console.log(d.Language);});

					var emojis = filtered.map(function(d){return d.Emoji;}).join('        ');
					console.log(emojis);
					console.log(filtered);
					var colorScale = d3.scaleOrdinal().domain(languages)
													.range(d3.schemeCategory10);
					//var colors = d3.schemeCategory20().domain([])

					//create circular path
					/*backdrop.append('path')
						.attr('id', 'curve')
						.attr('fill', 'none')
						.attr('d', "M" + circleCenter[0] + "," + circleCenter[1] + " " +
						           "m" + -circleRadius + ", 0 " +
						           "a" + circleRadius + "," + circleRadius + " 0 1,0 " + 
						           			circleRadius*2  + ",0 " +
						           "a" + circleRadius + "," + circleRadius + " 0 1,0 " + 
						           			-circleRadius*2 + ",0Z");
						           				
					//add the text around the circle
					backdrop.append("text")
					    .attr("id", "curve-text")
					  	.append("textPath")
					  	//.attr("startOffset","40%")
						//.style("text-anchor","middle")
					    .attr("xlink:href", "#curve")
					    .style('font-size', 45)
					    .text(emojis);				
					backdrop.append("use")
					    .attr("id", "curve-line")
					    .attr("xlink:href", "#curve");*/

					//small circle	
					/*for (var k = 0; k < 26; k++) {
						backdrop.append('path')
							.attr('class', 'small-circle')
							.attr('fill', 'red')
							.attr('d', "M" + (495) + "," + 
										(653) + " " +
							           "m" + -35 + ", 0 " +
							           "a" + 35 + "," + 35 + " 0 1,0 " + 
							           			35*2  + ",0 " +
							           "a" + 35 + "," + 35 + " 0 1,0 " + 
							           			-35*2 + ",0Z")
							.attr('transform', 'translate(' + 498 + ',' + );
					}*/

					var smallCircleRadius = 55;
					var smallerCircleRadius = 45;
					console.log(filtered);
					var textElems = [];
					var coords = generateTextBlocks(filtered.length, circleRadius);

					for (var j = 0; j < coords.length; j++){
						backdrop.append('line')
								.attr('x1', (circleCenter[0]))
								.attr('y1', (circleCenter[1]))
								.attr('x2', coords[j].x)
								.attr('y2', coords[j].y)
								.style('stroke', colorScale(filtered[j].Language))
								.style('stroke-width', 5);
						backdrop.append('path')
								//.attr('stroke', colorScale(filtered[j].Language))
								.attr('fill', 'none')
								//.attr('stroke-width', 3)
								.attr('id', ('circle'+j))
								.attr('d', "M" + coords[j].x + "," + 
											coords[j].y + " " +
								           "m" + (-smallCircleRadius) + ", 0 " +
								           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " + 
								           			smallCircleRadius*2  + ",0 " +
								           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " + 
								           			-smallCircleRadius*2 + ",0Z")
								.attr('transform', 'rotate('+ (25.7*j) + ',' +	coords[j].x + ',' + coords[j].y +')');
						backdrop.append('path')
								.attr('stroke', colorScale(filtered[j].Language))
								.attr('fill', 'white')
								.attr('stroke-width', 5)
								//.attr('id', ('circle'+j))
								.attr('d', "M" + coords[j].x + "," + 
											coords[j].y + " " +
								           "m" + (-smallerCircleRadius-10) + ", 0 " +
								           "a" + smallerCircleRadius + "," + smallerCircleRadius + " 0 1,0 " + 
								           			smallerCircleRadius*2  + ",0 " +
								           "a" + smallerCircleRadius + "," + smallerCircleRadius + " 0 1,0 " + 
								           			-smallerCircleRadius*2 + ",0Z")
								.attr('transform', 'rotate('+ (25.7*j) + ',' +	coords[j].x + ',' + coords[j].y +')');
						backdrop.append('text')
										.attr('id', coords[j].id)
										.style('text-anchor', 'middle')
										.style('dominant-baseline', 'central')
										.attr('x', coords[j].x)
										.attr('y', coords[j].y)
										//.attr('width', 90)
										//.attr('height',90)
										.style('font-size', 50)
										.text(filtered[j].Emoji);

						backdrop.append('text')
							.attr('x', circleCenter[0])
							.attr('y', circleCenter[1])
							.attr('text-anchor', 'middle')
							.style('font-size', 100)
							.style('alignment-baseline', 'middle')
							.text(data[0].Emoji);
						var matchingEmojis = getMatchingCategory(data, filtered[j]);

						backdrop.append("text")
							    .attr("id", "small-curve-text")
							  	.append("textPath")
							  	.attr("startOffset","50%")
								.style("text-anchor","middle")
								.style('alignment-baseline', 'hanging')
							    .attr("xlink:href", ("#circle"+(j)))
							    .style('font-size', 35)
							    //.attr('x', 10)
							    //.attr('text-anchor', 'begin')
							    .text(matchingEmojis);				
						backdrop.append("use")
							    .attr("id", "small-curve-line")
							    .attr("xlink:href", "#circle"+(j));
					}

					/*for (var i = 0; i < coords.length; i++) {
						console.log(filtered[i]);
						console.log(coords[i]);
						var elem = backdrop.append('text')
												.attr('id', coords[i].id)
												.attr('x', coords[i].x)
												.attr('y', coords[i].y)
												.style('text-anchor', 'middle')
												.style('alignment-baseline', 'middle')
												//.attr('width', 40)
												//.attr('height',40)
												.style('font-size', 60)
												.text(filtered[i].Emoji);
						textElems.push(elem);
					}*/


					/*var angle = 0;
					//Split into two loops because the emoji at angle 0 is
					//at filtered[6]
					var smallCircleRadius = 50;
					for (var i = 3; i < filtered.length; i++) {
						angle = -(24*(i-3))
						console.log((i-3));
						backdrop.append('line')
								.attr('x1', circleCenter[0])
								.attr('y1', circleCenter[1])
								.attr('x2', circleCenter[0])
								.attr('y2', circleCenter[1]+ (circleRadius-70))
								.style('stroke', colorScale(filtered[i].Language))
								.style('stroke-width', 2)
								.attr('transform', 'rotate(' + angle + ',' 
															+ circleCenter[0] + ','
															+ circleCenter[1]+')');
						var smallCircle = backdrop.append('path')
									.attr('id', (i-6))
									.attr('fill', 'none')
									.attr('d', "M" + circleCenter[0] + "," + 
												(circleCenter[1] + circleRadius+10) + " " +
									           "m" + -smallCircleRadius + ", 0 " +
									           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " + 
									           			smallCircleRadius*2  + ",0 " +
									           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " + 
									           			-smallCircleRadius*2 + ",0Z")
									.attr('transform', 'rotate(' + angle + ',' 
																+ circleCenter[0] + ','
																+ circleCenter[1]+')');
						var matchingEmojis = getMatchingCategory(data, filtered[i]);

						backdrop.append("text")
							    .attr("id", "small-curve-text")
							  	.append("textPath")
							  	.attr("startOffset","25%")
								.style("text-anchor","middle")
							    .attr("xlink:href", ("#"+(i-6)))
							    .style('font-size', 17)
							    //.attr('x', 10)
							    //.attr('text-anchor', 'begin')
							    .text(matchingEmojis);				
						backdrop.append("use")
							    .attr("id", "small-curve-line")
							    .attr("xlink:href", "#"+(i-6));
					}

					for (var j = 0; j < 3; j++) {
						var angleCount = j+ 12;
						angle = -(24*(angleCount));
						console.log(angle);
						console.log('index: ' + (j+12));
						console.log(j);
						console.log(filtered[j]);
						var lineAdded = backdrop.append('line')
									.attr('x1', circleCenter[0])
									.attr('y1', circleCenter[1])
									.attr('x2', circleCenter[0])
									.attr('y2', circleCenter[1]+ (circleRadius - 70))
									.style('stroke', colorScale(filtered[j].Language))
									.style('stroke-width', 2)
									.attr('transform', 'rotate(' + angle + ',' 
																+ circleCenter[0] + ','
																+ circleCenter[1]+')');
						backdrop.append('path')
									.attr('id', angleCount)
									.attr('fill', 'none')
									.attr('d', "M" + circleCenter[0] + "," + 
												(circleCenter[1] + circleRadius+10) + " " +
									           "m" + -smallCircleRadius + ", 0 " +
									           "a" + smallCircleRadius/2 + "," + smallCircleRadius/2 + " 0 0,0 " + 
									           			smallCircleRadius*2  + ",0 " +
									           "a" + smallCircleRadius + "," + smallCircleRadius + " 0 1,0 " +
									           			-smallCircleRadius*2 + ",0Z")
									.attr('transform', 'rotate(' + angle + ',' 
																+ circleCenter[0] + ','
																+ circleCenter[1]+')');
						var matchingEmojis = getMatchingCategory(data, filtered[j]);

						backdrop.append("text")
							    .attr("id", "small-curve-text")
							  	.append("textPath")
							  	.attr("startOffset","50%")
								.style("text-anchor","middle")
							    .attr("xlink:href", ("#"+(angleCount+1)))
							    .style('font-size', 17)
							    //.attr('x', 30)
							    //.attr('text-anchor', 'begin')
							    .text(matchingEmojis);				
						backdrop.append("use")
							    .attr("id", "small-curve-line")
							    .attr("xlink:href", "#"+(angleCount+1));
						i += 1;
						console.log('after increment: ' + i);
					}
					//var circleData = generateSmallCircles(26, (circleRadius));
					//console.log(circleData.length);
					//circleData.forEach(function(c){
					//backdrop.selectAll('line').append('circle').attr('fill', "red");	
						

					//});
					/*d3.selectAll('.small-circle')
						.enter()*/

				}
			</script>
		</p>		
	</body>
</head>
</html>